-----------------------------------------------------------
    Overview
-----------------------------------------------------------
- avoid explicit construction of Cobs
	- probe C-space with a sampling scheme
- black-box collision detection module
	- develop planning algorithms independent of geometric models
- give up completeness
	- instead go for weaker notions
	- denseness is important
		- samples come arbitrariliy close to any configuration as iteration -> inf
		- deterministic dense sampling leads to resolution complete
		- random sampling is dense with probability 1
			- probabilistically complete
				- with enough points solution converges to 1
				- important is the !rate of convergence!

-----------------------------------------------------------
    C-Space distance and volume
-----------------------------------------------------------
- almost all algorithms need a measure of distance between 2 points in C
	- results in a metric space
- also important to define the volume of a subset of C
	- results in a measure space
- use invariant measures whenever possible

-----------------------------------------------------------
    Metric spaces
-----------------------------------------------------------
- (X,p) topological space X with function p : X x X -> R
	- nonnegativity
	- reflexivity
		- p(a,b) = 0 iff a = b
	- symmetry
	- triangle inequality
- Lp metrics are homeomorphic to norms on vector spaces
- any subspace Y in X becomes a metric space if you restric p's domain to Y x Y
	- means can use provided metrics on manifolds
- extension across cartesian products (X,px) and (Y,py)
	- Z = X x Y
	- pz(z,z') = pz([x,y],[x',y']) = c1*px(x,x') + c2*py(y,y')
		- c1 > 0 and c2 > 0
	- can also apply a p-1/p power to the combination
eg. SO(2) using complex numbers with any Lp metric from R2
	- takes shortcut by computing length of line segment connecting 2 points
	- actually a distortion
eg. SO(2) by comparing angles
	- p(t1,t2) = min(|t1-t2|, 2*pi - |t1-t2|)
		- t in [0,2pi]
	- equivalently the angle between 2 vectors
		- p((a1,b1), (a2,b2)) = cos-1(a1*a2 + b1*b2)
eg. SO(3) using quaterions
	- live in S3 from R4
		- can use Lp metric except for antipodal points (h = -h)
	- p(h1,h2) = min(||h1 - h2||, ||h1 + h2||)
		- difference of h1 to both h2 and -h2
		- ||.|| is any norm
	- similar problem to before of travelling inside S3 distortion
eg. SO(3) using quaterions "angle" between
	- extension of SO(2) angle comparison
	- for unit vector in Rn v1*v2 = cos(theta)
	- ps(h1,h2) = cos-1(a1*a2 + b1*b2 + c1*c2 + d1*d2)
		- with identification of h = -h
		- p(h1,h2) = min(ps(h1,h2), ps(h1,-h2))
- pseudometric for behaviour similar to a metric
	- may break symmetry, for example for travelling up/down a hill
	eg. potential function

-----------------------------------------------------------
    Measure theory basics
-----------------------------------------------------------
- a measure is a function producing real values for subsets of a metric space
	- ideally nonnegative value
- due to Banach-Tarski paradox, need conditions on a collection B of subsets to avoid paradox a #sigma algebra#
	1. includes empty set
	2. if C is in B, then X \ C also in B
	3. for any collection of a countable number of sets in B, their union must also be in B
	- elements in B are called the mesurable sets
eg. a nice sigma algebra, the Borrel sets
	- for any metric space (X,p), B(x,r) = {x' in X | p(x,x') < r} open balls
	- sets that can be constructed from these open balls using sigma algebra axioms
	- such as an open square in R2
		- can be constructed as the union of a countable number of balls
- a #measure# is then defined as a function u : B -> [0,inf] such that
	1. u(empty set) = 0
	2. for E1,E2,... countably number of pairwise disjoint measureable sets, u(union of Es) = sum u(Ei) 
eg. Lebesgue measure
- can be used to define general notions of integration
- #Haar measure# is good for some transformation groups including SO(N)
	- G represents a matrix group with real entries
	- for any measurable subset A in G and any element g in G
		- u(A) = u(gA) = u(Ag)